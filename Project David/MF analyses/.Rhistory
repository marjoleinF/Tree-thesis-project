nreps <- 10
ngensizes <- c(1, 5, 10)
palts <- c(0, 0.25, 0.5)
## Create objects for saving results (MSE for Bayesian approach, MSE2 for Breiman approach)
MSE <- data.frame(matrix(data = NA, nrow = nfolds*nreps,
ncol = 3 + length(ngensizes) + length(ngensizes)*length(palts)))
BaSmear_design <- expand.grid(ngensizes, palts)
colnames(BaSmear_design) <- c("ngen", "palt")
colnames(MSE) <- c("tree", "BART", "Born-again tree",
paste0("N=", ngensizes),
paste0("N=", BaSmear_design[ , 1], ", palt=", BaSmear_design[ , 2]))
rownames(MSE) <- paste0("rep", sort(rep(1:nreps, times = nfolds)), "_fold", rep(1:nfolds, times = nreps))
#MSE <- MSE[ , -which(is.na(colnames(MSE)))]
tree_size <- acc <- MSE
set.seed(42)
for (k in 1:nreps) {
## Generate train-test splits
fold_ids <- sample(rep(1:nfolds, times = ceiling(nrow(data)/nfolds)),
size = nrow(data), replace = FALSE)
for (i in 1:nfolds) {
## Select train and test data
traindat <- data[fold_ids != i, ]
testdat <- data[fold_ids == i, ]
train_x <- traindat[ , -which(names(traindat) == "Class")]
train_y <- as.numeric(traindat$Class) - 1
test_x <- testdat[ , -which(names(data) == "Class")]
test_y <- as.numeric(testdat$Class) - 1
## Fit regular GLMM tree
gt <- glmtree(Class ~ 1 | ., data = traindat, family = binomial)
pred_gt <- predict(gt, newdata = testdat, type = "response")
MSE[(k-1)*10+i, 1] <- mean((test_y - pred_gt)^2)
acc[(k-1)*10+i, 1] <- mean(test_y - pred_gt > .5)
tree_size[(k-1)*10+i, 1] <- (length(gt)-1)/2
## 1) Fit (and evaluate) BART
## 2) Generate surrogate data
## 3) Fit and evaluate tree fitted to surrogate data
## Fit Bayesian born-again approach
##
brt <- bart(x.train = train_x, y.train = train_y, x.test = test_x,
ntree = 100, combinechains = TRUE, verbose = FALSE)
brt_test_preds <- binomial()$linkinv(colMeans(brt$yhat.test))
brt_train_preds <- binomial()$linkinv(colMeans(brt$yhat.train))
MSE[(k-1)*10+i, 2] <- mean((test_y - brt_test_preds)^2)
acc[(k-1)*10+i, 2] <- mean(test_y - brt_test_preds > .5)
surr_dat <- traindat
surr_dat$Class <- brt_train_preds
ba_gt <- lmtree(Class ~ 1 | ., data = surr_dat)
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, 3] <- mean((test_y - pred_babart)^2)
acc[(k-1)*10+i, 3] <- mean(test_y - pred_babart > .5)
tree_size[(k-1)*10+i, 3] <- (length(ba_gt)-1)/2
posterior <- binomial()$linkinv(brt$yhat.train)
for (ngen in ngensizes) {
surr_dat <- gendata_bay(data = traindat, PPD = posterior, ngen = ngen)
ba_gt <- lmtree(y_gen ~ 1 | . - Class, data = surr_dat,
weights = rep(1/ngen, times = nrow(surr_dat)))
pred_babart <- predict(ba_gt, newdata = testdat)
acc[(k-1)*10+i, 3+match(ngen, ngensizes)] <- mean(test_y - pred_babart > .5)
MSE[(k-1)*10+i, 3+match(ngen, ngensizes)] <- mean((test_y - pred_babart)^2)
tree_size[(k-1)*10+i, 3+match(ngen, ngensizes)] <- (length(ba_gt)-1)/2
}
## Fit Breiman born-again approach
##
for (ngen_palt in 1:nrow(BaSmear_design)) {
palt <- BaSmear_design$palt[ngen_palt]
ngen <- BaSmear_design$ngen[ngen_palt]
surr_dat <- gendata_smr(data = traindat, palt = palt, ngen = ngen)
brt <- bart(x.train = train_x, y.train = train_y, x.test = surr_dat,
verbose = FALSE, ntree = 100, combinechains = TRUE)
y_gen <-  binomial()$linkinv(colMeans(brt$yhat.test))
surr_dat <- cbind(surr_dat, y_gen)
ba_gt <- lmtree(y_gen ~ 1 | . - Class, data = surr_dat,
weights = rep(1/ngen, times = nrow(surr_dat)))
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
mean((test_y - pred_babart)^2)
acc[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
mean(test_y - pred_babart > 0.5)
tree_size[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
(length(ba_gt)-1)/2
}
print(paste0("Finished fold ", i, " of repetition ", k))
save(MSE, file = "Ionosphere MSE.Rda")
save(acc, file = "Ionosphere acc.Rda")
save(tree_size, file = "Ionosphere tree_size.Rda")
}
}
## Bayesian data generation function
## Returns X_gen, y_gen
gendata_bay <- function(data, PPD, ngen) {
if (nrow(data) != ncol(PPD))
stop("Amount of observations in PPD is different from data")
index_gen <- sample.int(n = nrow(data), size = ngen*nrow(data), replace = TRUE)
x_gen <- data[index_gen, ]
## Posterior Predictive Distribution has 2000 rows (default) and nobs columns
## Thus, for each bootstrap sampled row, selected correspdonding column
## and sample a random value from that posterior
y_gen <- sapply(index_gen, function(i) sample(x = PPD[ , i], size = 1))
return(cbind(x_gen, y_gen))
}
## Smearing data generation function
## Returns X_gen only
gendata_smr <- function(data, palt = 0.5, ngen) {
if (palt < 0 | palt > 1) stop("palt must be bound between between 0 and 1")
index_gen <- sample.int(n = nrow(data), size = ngen*nrow(data), replace = TRUE)
gen_data <- data[index_gen, ]
## With probability palt, replace value in X_gen with random sample from
## corresponding column
if (palt != 0) {
for (i in 1:nrow(gen_data)) {
for (j in 1:ncol(gen_data)) {
if (rbinom(n = 1, size = 1, prob = palt)) {
gen_data[i, j] <- sample(x = data[ , j], size = 1)
}
}
}
}
return(gen_data)
}
library("partykit")
library("dbarts")
library("mlbench")
data(BreastCancer)
data <- BreastCancer
data <- na.omit(data)
data[ , sapply(data, is.ordered)] <- sapply(data[ , sapply(data, is.ordered)], as.numeric)
nfolds <- 10
nreps <- 10
ngensizes <- c(1, 5, 10)
palts <- c(0, 0.25, 0.5)
## Create objects for saving results (MSE for Bayesian approach, MSE2 for Breiman approach)
MSE <- data.frame(matrix(data = NA, nrow = nfolds*nreps,
ncol = 3 + length(ngensizes) + length(ngensizes)*length(palts)))
BaSmear_design <- expand.grid(ngensizes, palts)
colnames(BaSmear_design) <- c("ngen", "palt")
colnames(MSE) <- c("tree", "BART", "Born-again tree",
paste0("N=", ngensizes),
paste0("N=", BaSmear_design[ , 1], ", palt=", BaSmear_design[ , 2]))
rownames(MSE) <- paste0("rep", sort(rep(1:nreps, times = nfolds)), "_fold", rep(1:nfolds, times = nreps))
#MSE <- MSE[ , -which(is.na(colnames(MSE)))]
tree_size <- acc <- MSE
set.seed(42)
for (k in 1:nreps) {
## Generate train-test splits
fold_ids <- sample(rep(1:nfolds, times = ceiling(nrow(data)/nfolds)),
size = nrow(data), replace = FALSE)
for (i in 1:nfolds) {
## Select train and test data
traindat <- data[fold_ids != i, -which(names(data) == "Id")]
testdat <- data[fold_ids == i, ]
## Check whether all factor levels in test are also in train, else move obs.
for (fact in c("Bare.nuclei", "Bl.cromatin", "Normal.nucleoli", "Mitoses")) {
levs <- unique(testdat[ , fact]) %in% unique(traindat[ , fact])
if (!all(levs)) {
test <- test[-which(!testdat[ , fact] %in% unique(testdat[ , fact])[levs]), ]
print(paste0("Levels of ", i, " omitted from test data: ",
unique(testdat[ , fact])[!levs]))
}
}
train_x <- traindat[ , -which(names(traindat) == "Class")]
train_y <- as.numeric(traindat$Class) - 1
test_x <- testdat[ , -which(names(data) == "Class")]
test_y <- as.numeric(testdat$Class) - 1
## Fit regular GLMM tree
gt <- glmtree(Class ~ 1 | ., data = traindat, family = binomial)
pred_gt <- predict(gt, newdata = testdat, type = "response")
MSE[(k-1)*10+i, 1] <- mean((test_y - pred_gt)^2)
acc[(k-1)*10+i, 1] <- mean(test_y - pred_gt > .5)
tree_size[(k-1)*10+i, 1] <- (length(gt)-1)/2
## 1) Fit (and evaluate) BART
## 2) Generate surrogate data
## 3) Fit and evaluate tree fitted to surrogate data
## Fit Bayesian born-again approach
##
brt <- bart(x.train = train_x, y.train = train_y, x.test = test_x,
ntree = 100, combinechains = TRUE, verbose = FALSE)
brt_test_preds <- binomial()$linkinv(colMeans(brt$yhat.test))
brt_train_preds <- binomial()$linkinv(colMeans(brt$yhat.train))
MSE[(k-1)*10+i, 2] <- mean((test_y - brt_test_preds)^2)
acc[(k-1)*10+i, 2] <- mean(test_y - brt_test_preds > .5)
surr_dat <- traindat
surr_dat$Class <- brt_train_preds
ba_gt <- lmtree(Class ~ 1 | ., data = surr_dat)
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, 3] <- mean((test_y - pred_babart)^2)
acc[(k-1)*10+i, 3] <- mean(test_y - pred_babart > .5)
tree_size[(k-1)*10+i, 3] <- (length(ba_gt)-1)/2
posterior <- binomial()$linkinv(brt$yhat.train)
for (ngen in ngensizes) {
try({
surr_dat <- gendata_bay(data = traindat, PPD = posterior, ngen = ngen)
ba_gt <- lmtree(y_gen ~ 1 | . - Class, data = surr_dat,
weights = rep(1/ngen, times = nrow(surr_dat)))
pred_babart <- predict(ba_gt, newdata = testdat)
acc[(k-1)*10+i, 3+match(ngen, ngensizes)] <- mean(test_y - pred_babart > .5)
MSE[(k-1)*10+i, 3+match(ngen, ngensizes)] <- mean((test_y - pred_babart)^2)
tree_size[(k-1)*10+i, 3+match(ngen, ngensizes)] <- (length(ba_gt)-1)/2
})
}
## Fit Breiman born-again approach
##
for (ngen_palt in 1:nrow(BaSmear_design)) {
palt <- BaSmear_design$palt[ngen_palt]
ngen <- BaSmear_design$ngen[ngen_palt]
surr_dat <- gendata_smr(data = traindat, palt = palt, ngen = ngen)
brt <- bart(x.train = train_x, y.train = train_y, x.test = surr_dat,
verbose = FALSE, ntree = 100, combinechains = TRUE)
y_gen <-  binomial()$linkinv(colMeans(brt$yhat.test))
try({
surr_dat <- cbind(surr_dat, y_gen)
ba_gt <- lmtree(y_gen ~ 1 | . - Class, data = surr_dat,
weights = rep(1/ngen, times = nrow(surr_dat)))
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
mean((test_y - pred_babart)^2)
acc[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
mean(test_y - pred_babart > 0.5)
tree_size[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
(length(ba_gt)-1)/2
})
}
print(paste0("Finished fold ", i, " of repetition ", k))
save(MSE, file = "BreastCancer MSE.Rda")
save(acc, file = "BreastCancer acc.Rda")
save(tree_size, file = "BreastCancer tree_size.Rda")
}
}
## Bayesian data generation function
## Returns X_gen, y_gen
gendata_bay <- function(data, PPD, ngen) {
if (nrow(data) != ncol(PPD))
stop("Amount of observations in PPD is different from data")
index_gen <- sample.int(n = nrow(data), size = ngen*nrow(data), replace = TRUE)
x_gen <- data[index_gen, ]
## Posterior Predictive Distribution has 2000 rows (default) and nobs columns
## Thus, for each bootstrap sampled row, selected correspdonding column
## and sample a random value from that posterior
y_gen <- sapply(index_gen, function(i) sample(x = PPD[ , i], size = 1))
return(cbind(x_gen, y_gen))
}
## Smearing data generation function
## Returns X_gen only
gendata_smr <- function(data, palt = 0.5, ngen) {
if (palt < 0 | palt > 1) stop("palt must be bound between between 0 and 1")
index_gen <- sample.int(n = nrow(data), size = ngen*nrow(data), replace = TRUE)
gen_data <- data[index_gen, ]
## With probability palt, replace value in X_gen with random sample from
## corresponding column
if (palt != 0) {
for (i in 1:nrow(gen_data)) {
for (j in 1:ncol(gen_data)) {
if (rbinom(n = 1, size = 1, prob = palt)) {
gen_data[i, j] <- sample(x = data[ , j], size = 1)
}
}
}
}
return(gen_data)
}
library("dbarts")
library("mlbench")
library("partykit")
data(Ozone)
sapply(Ozone, function(x) table(is.na(x)))
data <- Ozone[ , -9]
data <- na.omit(data)
nfolds <- 10
nreps <- 10
ngensizes <- c(1, 5, 10)
palts <- c(0, 0.25, 0.5, 1.0)
## Create objects for saving results (MSE for Bayesian approach, MSE2 for Breiman approach)
MSE <- data.frame(matrix(data = NA, nrow = nfolds*nreps,
ncol = 3 + length(ngensizes) + length(ngensizes)*length(palts)))
BaSmear_design <- expand.grid(ngensizes, palts)
colnames(BaSmear_design) <- c("ngen", "palt")
colnames(MSE) <- c("GLMM_tree", "Bart", "Ba",
paste0("BaBayes_N=", ngensizes),
paste0("BaSmear_N=", BaSmear_design[ , 1], "_palt=", BaSmear_design[ , 2]))
rownames(MSE) <- paste0("rep", sort(rep(1:nreps, times = nfolds)), "_fold", rep(1:nfolds, times = nreps))
#MSE <- MSE[ , -which(is.na(colnames(MSE)))]
tree_size <- MSE
set.seed(152)
## k =3, seed is 43
## k =3, seed is 142
## k = 6, seed is 168
## k = 7, seed is 152
for (k in 7:nreps) {
## Generate train-test splits
fold_ids <- sample(rep(1:nfolds, times = ceiling(nrow(data)/nfolds)),
size = nrow(data), replace = FALSE)
for (i in 1:nfolds) {
## Select train and test data
traindat <- data[fold_ids != i, ]
testdat <- data[fold_ids == i, ]
## Fit regular GLMM tree
gt <- lmtree(V4 ~ 1 | ., data = traindat)
pred_gt <- predict(gt, newdata = testdat)
MSE[(k-1)*10+i, 1] <- mean((testdat$V4 - pred_gt)^2)
tree_size[(k-1)*10+i, 1] <- (length(gt)-1)/2
## 1) Fit (and evaluate) BART
## 2) Generate surrogate data
## 3) Fit and evaluate tree fitted to surrogate data
## Fit Bayesian born-again approach
brt <- bart2(V4 ~ ., data = traindat, test = testdat, n.trees = 100,
combineChains = TRUE, verbose = FALSE)
MSE[(k-1)*10+i, 2] <- mean((testdat$V4 - brt$yhat.test.mean)^2)
surr_dat <- traindat
surr_dat$V4 <- brt$yhat.train.mean
ba_gt <- lmtree(V4 ~ 1 | ., data = surr_dat)
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, 3] <- mean((testdat$V4 - pred_babart)^2)
tree_size[(k-1)*10+i, 3] <- (length(ba_gt)-1)/2
posterior <- brt$yhat.train
for (ngen in ngensizes) {
surr_dat <- gendata_bay(data = traindat, PPD = posterior, ngen = ngen)
ba_gt <- lmtree(y_gen ~ 1 | . - V4, data = surr_dat,
weights = rep(1/ngen, times = nrow(surr_dat)))
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, 3+match(ngen, ngensizes)] <- mean((testdat$V4 - pred_babart)^2)
tree_size[(k-1)*10+i, 3+match(ngen, ngensizes)] <- (length(ba_gt)-1)/2
}
## Fit Breiman born-again approach
for (ngen_palt in 1:nrow(BaSmear_design)) {
palt <- BaSmear_design$palt[ngen_palt]
ngen <- BaSmear_design$ngen[ngen_palt]
surr_dat <- gendata_smr(data = traindat, palt = palt, ngen = ngen)
brt <- bart2(V4 ~ ., data = traindat, test = surr_dat, verbose = FALSE,
n.trees = 100, combineChains = TRUE)
y_gen <- brt$yhat.test.mean
surr_dat <- cbind(surr_dat, y_gen)
ba_gt <- lmtree(y_gen ~ 1 | . -V4, data = surr_dat,
weights = rep(1/ngen, times = nrow(surr_dat)))
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
mean((testdat$V4 - pred_babart)^2)
tree_size[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
(length(ba_gt)-1)/2
}
print(paste0("Finished fold ", i, " of repetition ", k))
save(MSE, file = "Ozone MSE.Rda")
save(tree_size, file = "Ozone tree_size.Rda")
}
}
save(MSE, file = "Ozone MSE.Rda")
save(tree_size, file = "Ozone tree_size.Rda")
library("dbarts")
library("mlbench")
library("partykit")
data(Ozone)
sapply(Ozone, function(x) table(is.na(x)))
data <- Ozone[ , -9]
data <- na.omit(data)
nfolds <- 10
nreps <- 10
ngensizes <- c(1, 5, 10)
palts <- c(0, 0.25, 0.5, 1.0)
## Create objects for saving results (MSE for Bayesian approach, MSE2 for Breiman approach)
MSE <- data.frame(matrix(data = NA, nrow = nfolds*nreps,
ncol = 3 + length(ngensizes) + length(ngensizes)*length(palts)))
BaSmear_design <- expand.grid(ngensizes, palts)
colnames(BaSmear_design) <- c("ngen", "palt")
colnames(MSE) <- c("GLMM_tree", "Bart", "Ba",
paste0("BaBayes_N=", ngensizes),
paste0("BaSmear_N=", BaSmear_design[ , 1], "_palt=", BaSmear_design[ , 2]))
rownames(MSE) <- paste0("rep", sort(rep(1:nreps, times = nfolds)), "_fold", rep(1:nfolds, times = nreps))
#MSE <- MSE[ , -which(is.na(colnames(MSE)))]
tree_size <- MSE
set.seed(152)
## k =3, seed is 43
## k =3, seed is 142
## k = 6, seed is 168
## k = 7, seed is 152
for (k in 1:nreps) {
## Generate train-test splits
fold_ids <- sample(rep(1:nfolds, times = ceiling(nrow(data)/nfolds)),
size = nrow(data), replace = FALSE)
for (i in 1:nfolds) {
## Select train and test data
traindat <- data[fold_ids != i, ]
testdat <- data[fold_ids == i, ]
## Fit regular GLMM tree
gt <- lmtree(V4 ~ 1 | ., data = traindat)
pred_gt <- predict(gt, newdata = testdat)
MSE[(k-1)*10+i, 1] <- mean((testdat$V4 - pred_gt)^2)
tree_size[(k-1)*10+i, 1] <- (length(gt)-1)/2
## 1) Fit (and evaluate) BART
## 2) Generate surrogate data
## 3) Fit and evaluate tree fitted to surrogate data
## Fit Bayesian born-again approach
brt <- bart2(V4 ~ ., data = traindat, test = testdat, n.trees = 100,
combineChains = TRUE, verbose = FALSE)
MSE[(k-1)*10+i, 2] <- mean((testdat$V4 - brt$yhat.test.mean)^2)
surr_dat <- traindat
surr_dat$V4 <- brt$yhat.train.mean
ba_gt <- lmtree(V4 ~ 1 | ., data = surr_dat)
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, 3] <- mean((testdat$V4 - pred_babart)^2)
tree_size[(k-1)*10+i, 3] <- (length(ba_gt)-1)/2
posterior <- brt$yhat.train
for (ngen in ngensizes) {
surr_dat <- gendata_bay(data = traindat, PPD = posterior, ngen = ngen)
ba_gt <- lmtree(y_gen ~ 1 | . - V4, data = surr_dat,
weights = rep(1/ngen, times = nrow(surr_dat)))
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, 3+match(ngen, ngensizes)] <- mean((testdat$V4 - pred_babart)^2)
tree_size[(k-1)*10+i, 3+match(ngen, ngensizes)] <- (length(ba_gt)-1)/2
}
## Fit Breiman born-again approach
for (ngen_palt in 1:nrow(BaSmear_design)) {
palt <- BaSmear_design$palt[ngen_palt]
ngen <- BaSmear_design$ngen[ngen_palt]
surr_dat <- gendata_smr(data = traindat, palt = palt, ngen = ngen)
brt <- bart2(V4 ~ ., data = traindat, test = surr_dat, verbose = FALSE,
n.trees = 100, combineChains = TRUE)
y_gen <- brt$yhat.test.mean
surr_dat <- cbind(surr_dat, y_gen)
ba_gt <- lmtree(y_gen ~ 1 | . -V4, data = surr_dat,
weights = rep(1/ngen, times = nrow(surr_dat)))
pred_babart <- predict(ba_gt, newdata = testdat)
MSE[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
mean((testdat$V4 - pred_babart)^2)
tree_size[(k-1)*10+i, match(ngen, ngensizes) + match(palt, palts)*length(ngensizes) + 3] <-
(length(ba_gt)-1)/2
}
print(paste0("Finished fold ", i, " of repetition ", k))
save(MSE, file = "Ozone MSE.Rda")
save(tree_size, file = "Ozone tree_size.Rda")
}
}
head(airquality)
nrow(airquality)
library("mice")
md.pattern(airquality, rotate.names = TRUE)
set.seed(42)
imp <- mice(airquality, m = 5)
imp1 <- complete(imp, action = "all", include = FALSE)
imp1
imp1 <- do.call(complete(imp, action = "all", include = FALSE), rdind))
imp1 <- do.call(complete(imp, action = "all", include = FALSE), rbind)
imp1 <- do.call(rbind, complete(imp, action = "all", include = FALSE))
dim(imp1)
library("partykit")
?ctree
ctree(Wind ~ ., data = imp1, weights = 1/5)
ctree(Wind ~ ., data = imp1, weights = rep(1/5, times = nrowm(imp1))
)
ctree(Wind ~ ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
ct <- ctree(Wind ~ ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(ct)
gt <- glmtree(Wind ~ 1 | ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(gt)
?mob_control
plot(ct, type = "simple")
dim(airquality)
airquality$Ozone
head(airquality)
nrow(airquality)
library("mice")
md.pattern(airquality, rotate.names = TRUE)
set.seed(42)
imp <- mice(airquality, m = 5)
imp1 <- do.call(rbind, complete(imp, action = "all", include = FALSE))
library("partykit")
ct <- ctree(Ozone ~ ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(ct, type = "simple")
plot(ct)
ct[[1]]$node$info
ct[[1]]$data
ct[[1]]$data$`(weights)` <- 1
plot(ct)
ct <- ctree(Ozone ~ ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(ct)
ct$data
ct$data$`(weights)` <- 1
plot(ct)
ct <- ctree(Ozone ~ ., data = imp1, weights = rep(5, times = nrow(imp1)))
plot(ct)
ct <- ctree(Ozone ~ ., data = imp1, alpha = .00001,weights = rep(5, times = nrow(imp1)))
plot(ct)
ct <- ctree(Ozone ~ ., data = imp1, alpha = .00000000001,weights = rep(5, times = nrow(imp1)))
plot(ct)
ct$data$`(weights)` <- 1
plot(ct)
ct <- ctree(Ozone ~ ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(ct)
ct$data$`(weights)` <- 1
plot(ct)
ct[[1]]$node$info$nobs
gt <- glmtree(Wind ~ 1 | ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(gt)
gt$data$`(weights)` <- 1
plot(gt)
?plot.partykit
?plot.party
?node_terminal
gt <- glmtree(OZone ~ 1 | ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
gt <- glmtree(Ozone ~ 1 | ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
gt$data$`(weights)` <- 1
gt <- glmtree(Ozone ~ 1 | ., data = imp1, weights = rep(1/5, times = nrow(imp1)), family = gaussian)
gt <- glmtree(Ozone ~ 1 | ., data = imp1, weights = rep(1/5, times = nrow(imp1)),
family = gaussian)
gt$data$`(weights)` <- 1
plot(gt)
plot(ct, gp = gpar(cex = 0.7))
ct <- ctree(Ozone ~ ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(ct, gp = gpar(cex = 0.6)) ## gp arg specified to reduce symbol and text sizes
```{r, fig.width=5, fig,height=4}
ct <- ctree(Ozone ~ ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(ct, gp = gpar(cex = 0.6)) ## gp arg specified to reduce symbol and text sizes
plot(ct, gp = gpar(cex = 0.6)) ## gp arg specified to reduce symbol and text sizes
ct <- ctree(Ozone ~ ., data = imp1, weights = rep(1/5, times = nrow(imp1)))
plot(ct, gp = gpar(cex = 0.6)) ## gp arg specified to reduce symbol and text sizes
